#pragma once

#include <memory>
#include <vector>
#include <cstdint>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_inverse.hpp>
#include "GLTFLoader.h"
#include "SceneObject.hpp"

#include "utils/physical_device_utils.hpp"

class Camera;
class Scene;

struct UniformBufferObject {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
    glm::mat4 viewInverse;
    glm::mat4 projInverse;
    glm::vec3 cameraPos;
    float time;
};

struct LightingUBO {
    glm::vec3 lightPositions[4];
    glm::vec3 lightColors[4];
    float lightIntensities[4];
    int lightCount;
    glm::vec3 ambientLight;
    float exposure;
};

struct AccelerationStructure {
    VkAccelerationStructureKHR handle = VK_NULL_HANDLE;
    VkBuffer buffer = VK_NULL_HANDLE;
    VkDeviceMemory memory = VK_NULL_HANDLE;
    VkDeviceAddress deviceAddress = 0;
};

class SimpleRenderer {
public:
    SimpleRenderer(GLFWwindow* window);
    ~SimpleRenderer();

    void beginFrame();
    void render(Camera* camera, Scene* scene);
    void endFrame();
    // void initGeometry(Scene* scene);
    
    const vk::raii::Device& getDevice() const { return m_device; }

private:
    void initVulkan();
    void createInstance();
    void createSurface();
    void pickPhysicalDevice();
    void selectMsaaSamples();
    void createLogicalDevice();
    void createSwapChain();
    void createImageViews();
    // void createRenderPass();
    // void createFramebuffers();
    void createCommandPool();
    void createCommandBuffers();
    void createSyncObjects();
    void createVertexBuffer(const std::vector<GLTFVertex>& vertices);
    void createIndexBuffer(const std::vector<uint32_t>& indices);
    // void createVertexBufferFromData(const std::vector<GLTFVertex>& vertices);
    // void createIndexBufferFromData(const std::vector<uint32_t>& indices);
    void createColorResources();
    void createDepthResources();
    void createTextureSampler();
    void createGraphicsPipeline();
    void createDescriptorSetLayout();
    void createUniformBuffers();
    void createTextureImages();
    // void createLightingBuffers();
    void createDescriptorPool();
    void createDescriptorSets();
    void updateUniformBuffers(const Camera* camera) const;
    void updateLightingBuffer(uint32_t currentImage);
    void recordCommandBuffer(std::uint32_t imageIndex);
    void loadScene();

    // image stuff
    void createImage(
      std::uint32_t width,
      std::uint32_t height,
      uint32_t mipLevels,
      vk::SampleCountFlagBits numSamples,
      vk::Format format,
      vk::ImageTiling tiling,
      vk::ImageUsageFlags usage,
      vk::MemoryPropertyFlags properties,
      vk::raii::Image& image,
      vk::raii::DeviceMemory& imageMemory
    );
    auto createImageView(
      vk::raii::Image& image,
      vk::Format format,
      vk::ImageAspectFlags aspectFlags,
      uint32_t mipLevels
    ) -> vk::raii::ImageView;
    
    bool isDeviceSuitable(const vk::raii::PhysicalDevice& device);
    static bool checkDeviceExtensionSupport(const vk::raii::PhysicalDevice& device);
    // void loadRayTracingFunctions();
    // void createAccelerationStructures();
    void cleanupAccelerationStructures();
    void createRayTracingPipeline();
    void createRayTracingDescriptorSets();
    void createRayTracingStorageImage();
    void cleanupRayTracingPipeline();
    void cleanupRayTracingStorageImage();
    
    void createBuffer(
      vk::DeviceSize size,
      vk::BufferUsageFlags usage,
      vk::MemoryPropertyFlags properties,
      vk::raii::Buffer& buffer,
      vk::raii::DeviceMemory& bufferMemory
    );

    void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size);
    VkCommandBuffer beginSingleTimeCommands();
    void endSingleTimeCommands(VkCommandBuffer commandBuffer);
    uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties);
    VkDeviceAddress getBufferDeviceAddress(VkBuffer buffer) const;
    void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, VkPipelineStageFlags srcStage, VkPipelineStageFlags dstStage, VkAccessFlags srcAccess, VkAccessFlags dstAccess);

    QueueFamilyIndices m_queueFamilyIndices;
    vk::raii::Context m_context;
    vk::raii::Instance m_instance = nullptr;
    vk::raii::SurfaceKHR m_surface = nullptr;
    vk::raii::PhysicalDevice m_physicalDevice = nullptr;
    vk::raii::Device m_device = nullptr;
    vk::raii::Queue m_graphicsQueue = nullptr;
    vk::raii::Queue m_presentQueue = nullptr;

    vk::raii::SwapchainKHR m_swapChain = nullptr;
    std::vector<vk::Image> m_swapChainImages;
    std::vector<vk::raii::ImageView> m_swapChainImageViews;

    vk::Format m_swapChainImageFormat;
    vk::Extent2D m_swapChainExtent;

    VkRenderPass m_renderPass;
    std::vector<VkFramebuffer> m_swapChainFramebuffers;
    
    vk::CommandPool m_commandPool = nullptr;
    std::vector<vk::raii::CommandBuffer> m_commandBuffers;

    std::vector<SceneObject> m_sceneObjects;

    VkBuffer m_vertexBuffer;
    VkDeviceMemory m_vertexBufferMemory;
    VkBuffer m_indexBuffer;
    VkDeviceMemory m_indexBufferMemory;
    uint32_t m_vertexCount;
    uint32_t m_indexCount;

    vk::SampleCountFlagBits m_msaaSamples = vk::SampleCountFlagBits::e1;
    vk::raii::PipelineLayout m_pipelineLayout = nullptr;
    vk::raii::Pipeline m_graphicsPipeline = nullptr;
    
    vk::raii::DescriptorSetLayout m_descriptorSetLayout = nullptr;
    vk::raii::DescriptorPool m_descriptorPool = nullptr;

    // color attachment
    vk::raii::Image m_colorImage = nullptr;
    vk::raii::DeviceMemory m_colorImageMemory = nullptr;
    vk::raii::ImageView m_colorImageView = nullptr;

    // depth attachment
    vk::raii::Image m_depthImage = nullptr;
    vk::raii::DeviceMemory m_depthImageMemory = nullptr;
    vk::raii::ImageView m_depthImageView = nullptr;

    vk::raii::Sampler m_textureSampler = nullptr;
    
    std::vector<VkBuffer> m_lightingBuffers;
    std::vector<VkDeviceMemory> m_lightingBuffersMemory;
    std::vector<void*> m_lightingBuffersMapped;

    std::vector<vk::raii::Semaphore> m_imageAvailableSemaphores;
    std::vector<vk::raii::Semaphore> m_renderFinishedSemaphores;
    std::vector<vk::raii::Fence> m_inFlightFences;
    
    uint32_t m_currentFrame;
    uint32_t m_imageIndex;
    
    GLFWwindow* m_window;
    
    // uint32_t m_graphicsQueueFamilyIndex;
    // uint32_t m_presentQueueFamilyIndex;
    
    AccelerationStructure m_bottomLevelAS;
    AccelerationStructure m_topLevelAS;
    VkBuffer m_instancesBuffer;
    VkDeviceMemory m_instancesMemory;
    
    VkImage m_rtStorageImage;
    VkDeviceMemory m_rtStorageMemory;
    VkImageView m_rtStorageImageView;
    VkFormat m_rtStorageFormat;
    VkDescriptorSetLayout m_rtDescriptorSetLayout;
    VkPipelineLayout m_rtPipelineLayout;
    VkPipeline m_rtPipeline;
    VkDescriptorPool m_rtDescriptorPool;
    std::vector<VkDescriptorSet> m_rtDescriptorSets;
    VkBuffer m_rtShaderBindingTable;
    VkDeviceMemory m_rtShaderBindingTableMemory;
    VkStridedDeviceAddressRegionKHR m_rtRaygenRegion{};
    VkStridedDeviceAddressRegionKHR m_rtMissRegion{};
    VkStridedDeviceAddressRegionKHR m_rtHitRegion{};
    VkStridedDeviceAddressRegionKHR m_rtCallableRegion{};
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR m_rtProperties{};

    bool m_rtReady;

    PFN_vkCreateAccelerationStructureKHR m_vkCreateAccelerationStructureKHR = nullptr;
    PFN_vkDestroyAccelerationStructureKHR m_vkDestroyAccelerationStructureKHR = nullptr;
    PFN_vkGetAccelerationStructureDeviceAddressKHR m_vkGetAccelerationStructureDeviceAddressKHR = nullptr;
    PFN_vkCmdBuildAccelerationStructuresKHR m_vkCmdBuildAccelerationStructuresKHR = nullptr;
    PFN_vkGetAccelerationStructureBuildSizesKHR m_vkGetAccelerationStructureBuildSizesKHR = nullptr;
    PFN_vkCreateRayTracingPipelinesKHR m_vkCreateRayTracingPipelinesKHR = nullptr;
    PFN_vkGetRayTracingShaderGroupHandlesKHR m_vkGetRayTracingShaderGroupHandlesKHR = nullptr;
    PFN_vkCmdTraceRaysKHR m_vkCmdTraceRaysKHR = nullptr;
    
    static constexpr int MAX_FRAMES_IN_FLIGHT = 2;
};
